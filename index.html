<!--
     TODO LIST
     
     [ ] WHen storyteller clicks a message, make that be the current "Send to" if one isn't already set.
     [ ] Add name of current msg target in the "Type your message..." box, i.e. "Type your messager to Neha."
     [ ] Maybe add message drafting for the storyteller, so that they can start a message to someone, then click someone else, start their message, and then come back
     [ ] Add role assignment tracking for the storyteller
     [ ] Add selection of roles from the script and random assignment to the players
     [ ] The list of all players and the send to combo box are redundant. Remove one of them after getting more UX on phone
     [ ] The preset collection of template options is being applied universally. Its a nice demo of a concept but it isn't buying anything yet. I think once we have role assignment then it might make more sense to have those things get filled in.
     [ ] "Reminder tokens" aka per-player notes. Potentially have the available set of reminders be informed by the characters on the script, maybe even solely the ones in play.
     [ ] Add ability to add/remove players.
     [X] More specifically on the above: there's some issue where If I try to adjust the number of players for a *new game* in a pre-existing room, the overall system seems to grab (maybe old?) messages and allows them to override my more recent choices. There might be a need for some kind of game identification or timestamping to deal with this.

     
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BotC Messenger - Simple</title>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.8.2.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .title {
            font-size: 1.8rem;
            color: #ff6b6b;
            margin-bottom: 10px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #ffd93d;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .messages {
            height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .message.from-storyteller {
            background: rgba(255, 215, 61, 0.2);
            border-left: 4px solid #ffd93d;
        }
        
        .message.from-player {
            background: rgba(38, 222, 129, 0.2);
            border-left: 4px solid #26de81;
        }
        
        .message-header {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .delivery-status {
            color: #26de81;
            font-size: 0.8rem;
        }
      
        .template-ui {
            background: rgba(255, 107, 107, 0.2);
            border: 1px dashed #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .template-field {
            margin: 10px 0;
        }
        
        .response-preview {
            background: rgba(38, 222, 129, 0.2);
            border: 1px solid #26de81;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
        }
        
        .compose-area {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .compose-area textarea {
            flex: 1;
            min-height: 50px;
            resize: vertical;
        }
        
        .compose-area button {
            margin: 0;
            min-width: 80px;
        }
        
        .storyteller-controls {
            background: rgba(255, 215, 61, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .template-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .template-btn {
            background: rgba(255, 215, 61, 0.3);
            border: 1px solid #ffd93d;
            color: #ffd93d;
            padding: 10px;
            font-size: 0.9rem;
        }
        
        .template-btn:hover {
            background: rgba(255, 215, 61, 0.5);
        }
        
        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .player-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid transparent;
        }
        
        .player-card.storyteller {
            border-color: #ffd93d;
        }
        
        .player-card.online {
            border-color: #26de81;
        }
        
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .status.connected {
            background: rgba(38, 222, 129, 0.2);
            color: #26de81;
        }
        
        .status.disconnected {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }
        
        .script-viewer-content {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .team-section {
            margin: 20px 0;
        }
        
        .team-header {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
        }
        
        .team-townsfolk {
            background: rgba(74, 144, 226, 0.3);
            color: #4a90e2;
        }
        
        .team-outsider {
            background: rgba(158, 158, 158, 0.3);
            color: #9e9e9e;
        }
        
        .team-minion {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
        
        .team-demon {
            background: rgba(139, 0, 0, 0.3);
            color: #8b0000;
        }
        
        .role-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            border-left: 4px solid;
        }
        
        .role-card.townsfolk {
            border-left-color: #4a90e2;
        }
        
        .role-card.outsider {
            border-left-color: #9e9e9e;
        }
        
        .role-card.minion {
            border-left-color: #ff6b6b;
        }
        
        .role-card.demon {
            border-left-color: #8b0000;
        }
        
        .role-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }
        
        .role-ability {
            font-size: 0.9rem;
            line-height: 1.4;
            opacity: 0.9;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 600px) {
            .compose-area {
                flex-direction: column;
            }
            
            .compose-area button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">🩸 Blood on the Clocktower</h1>
            <p>Simple Messaging App</p>
        </div>
        
        <!-- Setup Screen -->
        <div id="setupScreen" class="card">
            <div class="input-group">
                <label for="userType">I am the:</label>
                <select id="userType">
                    <option value="storyteller">Storyteller</option>
                    <option value="player">Player</option>
                </select>
            </div>
            
            <div id="storytellerSetup" class="hidden">
                <div class="input-group">
                    <label>Game Mode:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button type="button" id="newGameBtn" onclick="selectGameMode('new')" style="flex: 1;">🎲 New Game</button>
                        <button type="button" id="reconnectBtn" onclick="selectGameMode('reconnect')" style="flex: 1; background: #666;">🔄 Reconnect</button>
                    </div>
                </div>

                 <div class="input-group">
                    <label for="gameRoom">Game Room ID:</label>
                    <input type="text" id="gameRoom" placeholder="Enter or create room ID">
                    <button type="button" id="generateRoomBtn" onclick="generateRoomId()">Generate New Room</button>
                </div>
                
                <div id="newGameFields" class="input-group">
                    <label for="scriptSelect">Script:</label>
                    <select id="scriptSelect">
                        <option value="">Select a script...</option>
                    </select>
                </div>
                
                <div id="playerNamesField" class="input-group">
                    <label for="playerNames">Player Names (one per line):</label>
                    <textarea id="playerNames" rows="6" placeholder="Alice&#10;Bob&#10;Charlie&#10;Diana&#10;Eve"></textarea>
                </div>
            </div>
            
            <div id="playerSetup" class="hidden">
                <div class="input-group">
                    <label for="gameRoomPlayer">Game Room ID:</label>
                    <input type="text" id="gameRoomPlayer" placeholder="Enter room ID from Storyteller">
                    <button type="button" onclick="checkRoom()">Check Room</button>
                </div>
                
                <div id="playerNameSection" class="input-group hidden">
                    <label for="playerName">Your Name:</label>
                    <select id="playerName">
                        <option value="">Select your name...</option>
                    </select>
                </div>
                
                <div id="roomStatus" class="hidden"></div>
            </div>
            
            <button id="joinGameBtn" onclick="joinGame()">Start Game</button>
        </div>
        
        <!-- Game Screen -->
        <div id="gameScreen" class="card hidden">
            <div id="connectionStatus" class="status disconnected">
                Connecting...
            </div>
            
            <div class="input-group">
                <label>Script: <span id="displayScript"></span> | Room: <span id="displayRoom"></span></label>
            </div>
            
            <button id="scriptViewerToggle" onclick="toggleScriptViewer()">📜 View Script</button>
            
            <div class="players-list" id="playersList"></div>
            
            <!-- Script Viewer -->
            <div id="scriptViewer" class="card hidden" style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 id="scriptViewerTitle">Script Viewer</h3>
                    <button onclick="toggleScriptViewer()" style="background: #666; padding: 5px 10px; font-size: 12px;">✕ Close</button>
                </div>
                
                <div id="scriptContent">
                    <p>No script loaded</p>
                </div>
            </div>
            
            <!-- Storyteller Controls -->
            <div id="storytellerControls" class="storyteller-controls hidden">
                <h3>Storyteller Controls</h3>
                <div class="input-group">
                    <label for="targetPlayer">Send to:</label>
                    <select id="targetPlayer">
                        <option value="">Select player...</option>
                    </select>
                </div>
                
                <div class="template-buttons">
                    <button class="template-btn" onclick="useSimpleTemplate('Your role is {role}', 'role')">Assign Role</button>
                    <button class="template-btn" onclick="usePromptTemplate('Choose a player tonight.', 'I choose {player}.', ['player'])">Ask: Choose Player</button>
                    <button class="template-btn" onclick="useSimpleTemplate('You learn: {info}', 'info')">Give Info</button>
                    <button class="template-btn" onclick="usePromptTemplate('Use your ability tonight.', 'I use my ability on {player}.', ['player'])">Use Ability</button>
                </div>
            </div>
            
            <div class="messaging-area">
                <div class="messages" id="messages"></div>
                
                <div id="templateUI" class="template-ui hidden">
                    <h4 id="templateTitle">Template</h4>
                    <div id="templateFields"></div>
                    <div id="responsePreview" class="response-preview hidden"></div>
                    <button onclick="sendTemplateMessage()">Send Message</button>
                    <button onclick="cancelTemplate()">Cancel</button>
                </div>
                
                <div class="compose-area">
                    <textarea id="messageInput" placeholder="Type your message..."></textarea>
                    <button onclick="sendFreeMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PubNub Configuration - Replace with your keys
        const PUBNUB_PUBLISH_KEY = 'demo';
        const PUBNUB_SUBSCRIBE_KEY = 'demo';
        
        let pubnub;
        let currentUser = '';
        let currentRoom = '';
        let userType = '';
        let players = [];
        let isConnected = false;
        let currentTemplate = null;
        let sentMessages = new Map(); // Track messages we've sent locally
        let mostRecentSetupTimestamp = 0;

        // Embedded script definitions
        const EMBEDDED_SCRIPTS = {
            'trouble_brewing': {
                id: 'trouble_brewing',
                name: 'Trouble Brewing',
                author: 'Steven Medway & The Pandemonium Institute',
                description: 'The original Blood on the Clocktower script. Perfect for beginners.',
                roles: [
                    {
                        id: 'washerwoman',
                        name: 'Washerwoman',
                        team: 'townsfolk',
                        ability: 'You start knowing that 1 of 2 players is a particular Townsfolk.',
                        firstNight: true,
                        otherNights: false
                    },
                    {
                        id: 'librarian',
                        name: 'Librarian',
                        team: 'townsfolk',
                        ability: 'You start knowing that 1 of 2 players is a particular Outsider. (Or that zero are in play.)',
                        firstNight: true,
                        otherNights: false
                    },
                    {
                        id: 'investigator',
                        name: 'Investigator',
                        team: 'townsfolk',
                        ability: 'You start knowing that 1 of 2 players is a particular Minion.',
                        firstNight: true,
                        otherNights: false
                    },
                    {
                        id: 'chef',
                        name: 'Chef',
                        team: 'townsfolk',
                        ability: 'You start knowing how many pairs of evil players there are.',
                        firstNight: true,
                        otherNights: false
                    },
                    {
                        id: 'empath',
                        name: 'Empath',
                        team: 'townsfolk',
                        ability: 'Each night, you learn how many of your 2 alive neighbors are evil.',
                        firstNight: true,
                        otherNights: true
                    },
                    {
                        id: 'fortune_teller',
                        name: 'Fortune Teller',
                        team: 'townsfolk',
                        ability: 'Each night, choose 2 players: you learn if either is a Demon. There is a good player that registers as a Demon to you.',
                        firstNight: true,
                        otherNights: true
                    },
                    {
                        id: 'undertaker',
                        name: 'Undertaker',
                        team: 'townsfolk',
                        ability: 'Each night*, you learn which character died by execution today.',
                        firstNight: false,
                        otherNights: true
                    },
                    {
                        id: 'monk',
                        name: 'Monk',
                        team: 'townsfolk',
                        ability: 'Each night*, choose a player (not yourself): they are safe from the Demon tonight.',
                        firstNight: false,
                        otherNights: true
                    },
                    {
                        id: 'ravenkeeper',
                        name: 'Ravenkeeper',
                        team: 'townsfolk',
                        ability: 'If you die at night, you are woken to choose a player: you learn their character.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'virgin',
                        name: 'Virgin',
                        team: 'townsfolk',
                        ability: 'The first time you are nominated, if the nominator is a Townsfolk, they are executed immediately.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'slayer',
                        name: 'Slayer',
                        team: 'townsfolk',  
                        ability: 'Once per game, during the day, publicly choose a player: if they are the Demon, they die.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'soldier',
                        name: 'Soldier',
                        team: 'townsfolk',
                        ability: 'You are safe from the Demon.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'mayor',
                        name: 'Mayor',
                        team: 'townsfolk',
                        ability: 'If only 3 players live & no execution occurs, your team wins. If you die at night, another player might die instead.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'butler',
                        name: 'Butler',
                        team: 'outsider',
                        ability: 'Each night, choose a player (not yourself): tomorrow, you may only vote if they are voting too.',
                        firstNight: true,
                        otherNights: true
                    },
                    {
                        id: 'drunk',
                        name: 'Drunk',
                        team: 'outsider',
                        ability: 'You do not know you are the Drunk. You think you are a Townsfolk character, but your ability malfunctions.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'recluse',
                        name: 'Recluse',
                        team: 'outsider',
                        ability: 'You might register as evil & as a Minion or Demon, even when dead.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'saint',
                        name: 'Saint',
                        team: 'outsider',
                        ability: 'If you die by execution, your team loses.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'poisoner',
                        name: 'Poisoner',
                        team: 'minion',
                        ability: 'Each night, choose a player: they are poisoned tonight and tomorrow day.',
                        firstNight: true,
                        otherNights: true
                    },
                    {
                        id: 'spy',
                        name: 'Spy',
                        team: 'minion',
                        ability: 'Each night, you see the Grimoire. You might register as good & as a Townsfolk or Outsider.',
                        firstNight: true,
                        otherNights: true
                    },
                    {
                        id: 'scarlet_woman',
                        name: 'Scarlet Woman',
                        team: 'minion',
                        ability: 'If there are 5 or more players alive & the Demon dies, you become the Demon.',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'baron',
                        name: 'Baron',
                        team: 'minion',
                        ability: 'There are extra Outsiders in play. [+2 Outsiders]',
                        firstNight: false,
                        otherNights: false
                    },
                    {
                        id: 'imp',
                        name: 'Imp',
                        team: 'demon',
                        ability: 'Each night*, choose a player: they die. If you kill yourself this way, a Minion becomes the Imp.',
                        firstNight: false,
                        otherNights: true
                    }
                ],
                setup: {
                    5: { townsfolk: 3, outsider: 0, minion: 1, demon: 1 },
                    6: { townsfolk: 3, outsider: 1, minion: 1, demon: 1 },
                    7: { townsfolk: 5, outsider: 0, minion: 1, demon: 1 },
                    8: { townsfolk: 5, outsider: 1, minion: 1, demon: 1 },
                    9: { townsfolk: 5, outsider: 2, minion: 1, demon: 1 },
                    10: { townsfolk: 7, outsider: 0, minion: 2, demon: 1 },
                    11: { townsfolk: 7, outsider: 1, minion: 2, demon: 1 },
                    12: { townsfolk: 7, outsider: 2, minion: 2, demon: 1 },
                    13: { townsfolk: 9, outsider: 0, minion: 3, demon: 1 },
                    14: { townsfolk: 9, outsider: 1, minion: 3, demon: 1 },
                    15: { townsfolk: 9, outsider: 2, minion: 3, demon: 1 }
                }
            }
        };
        
        let currentScript = null;

        let gameMode = 'new'; // 'new' or 'reconnect'
        
        function selectGameMode(mode) {
            gameMode = mode;
            const newBtn = document.getElementById('newGameBtn');
            const reconnectBtn = document.getElementById('reconnectBtn');
            const generateBtn = document.getElementById('generateRoomBtn');
            const newGameFields = document.getElementById('newGameFields');
            const playerNamesField = document.getElementById('playerNamesField');
            const joinBtn = document.getElementById('joinGameBtn');

            if (mode === 'new') {
                newBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
                reconnectBtn.style.background = '#666';
                generateBtn.style.display = 'inline-block';
                newGameFields.style.display = 'block';
                playerNamesField.style.display = 'block';
                joinBtn.textContent = 'Start Game';
            } else {
                newBtn.style.background = '#666';
                reconnectBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
                generateBtn.style.display = 'none';
                newGameFields.style.display = 'none';
                playerNamesField.style.display = 'none';
                joinBtn.textContent = 'Rejoin Game';
            }
        }
        
        // Initialize user type selection and populate scripts
        document.getElementById('userType').addEventListener('change', function() {
            const storytellerSetup = document.getElementById('storytellerSetup');
            const playerSetup = document.getElementById('playerSetup');
            
            if (this.value === 'storyteller') {
                storytellerSetup.classList.remove('hidden');
                playerSetup.classList.add('hidden');
            } else {
                storytellerSetup.classList.add('hidden');
                playerSetup.classList.remove('hidden');
            }
        });
        
        // Populate script dropdown
        function populateScriptDropdown() {
            const scriptSelect = document.getElementById('scriptSelect');
            scriptSelect.innerHTML = '<option value="">Select a script...</option>';
            
            Object.values(EMBEDDED_SCRIPTS).forEach(script => {
                const option = document.createElement('option');
                option.value = script.id;
                option.textContent = script.name;
                scriptSelect.appendChild(option);
            });
        }
        
        function generateRoomId() {
            const roomId = 'botc_' + Math.random().toString(36).substr(2, 8);
            document.getElementById('gameRoom').value = roomId;
        }
        
        function checkRoom() {
            const roomId = document.getElementById('gameRoomPlayer').value.trim();
            if (!roomId) {
                alert('Please enter a room ID');
                return;
            }
            
            // Simple room check - create temporary connection
            const tempPubNub = new PubNub({
                publishKey: PUBNUB_PUBLISH_KEY,
                subscribeKey: PUBNUB_SUBSCRIBE_KEY,
                userId: 'temp_' + Math.random().toString(36).substr(2, 8)
            });
            
            tempPubNub.addListener({
                message: function(messageEvent) {
                    if (messageEvent.message.type === 'game_setup') {
                        const setup = messageEvent.message;
                        populatePlayerNames(setup.players);
                        tempPubNub.unsubscribeAll();
                    }
                }
            });
            
            tempPubNub.subscribe({ channels: [roomId] });
            
            tempPubNub.publish({
                channel: roomId,
                message: { type: 'request_game_state', from: 'temp_player', timestamp: Date.now() }
            });
            
            setTimeout(() => {
                if (document.getElementById('playerNameSection').classList.contains('hidden')) {
                    showRoomStatus('Room not found or no Storyteller online.', 'error');
                    tempPubNub.unsubscribeAll();
                }
            }, 3000);
        }
        
        function populatePlayerNames(playerList) {
            players = playerList;
            showRoomStatus(`Found game with ${playerList.length} players`, 'success');
            
            const playerSelect = document.getElementById('playerName');
            playerSelect.innerHTML = '<option value="">Select your name...</option>';
            playerList.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                playerSelect.appendChild(option);
            });
            
            document.getElementById('playerNameSection').classList.remove('hidden');
        }
        
        function showRoomStatus(message, type) {
            const statusEl = document.getElementById('roomStatus');
            statusEl.textContent = message;
            statusEl.className = type === 'success' ? 'status connected' : 'status disconnected';
            statusEl.classList.remove('hidden');
        }
        
        function joinGame() {
            userType = document.getElementById('userType').value;
            
            if (userType === 'storyteller') {
                currentRoom = document.getElementById('gameRoom').value.trim();
                
                if (!currentRoom) {
                    alert('Please enter a room ID');
                    return;
                }
                
                if (gameMode === 'new') {
                    const scriptId = document.getElementById('scriptSelect').value;
                    console.log('scriptId:', scriptId);
                    console.log('EMBEDDED_SCRIPTS[scriptId]:', EMBEDDED_SCRIPTS[scriptId]);
                    
                    if (!scriptId) {
                        alert('Please select a script');
                        return;
                    }
                    
                    const playerNamesText = document.getElementById('playerNames').value.trim();
                    if (!playerNamesText) {
                        alert('Please enter player names');
                        return;
                    }
                    
                    // Load the selected script
                    currentScript = EMBEDDED_SCRIPTS[scriptId];
                    players = playerNamesText.split('\n').map(name => name.trim()).filter(name => name);

                    // Populate target player dropdown for new games
                    const targetSelect = document.getElementById('targetPlayer');
                    targetSelect.innerHTML = '<option value="">Select player...</option>';
                    players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player;
                        option.textContent = player;
                        targetSelect.appendChild(option);
                    });
                }

                currentUser = 'Storyteller';
            } else {
                currentRoom = document.getElementById('gameRoomPlayer').value.trim();
                currentUser = document.getElementById('playerName').value;
                
                if (!currentRoom || !currentUser) {
                    alert('Please check the room and select your name first');
                    return;
                }
            }
            
            initializePubNub();
            // If storyteller starting new game, mark current time to ignore older setups
            if (userType === 'storyteller' && gameMode === 'new') {
                mostRecentSetupTimestamp = Date.now();
            }
            switchToGameScreen();
        }
        
        function initializePubNub() {
            pubnub = new PubNub({
                publishKey: PUBNUB_PUBLISH_KEY,
                subscribeKey: PUBNUB_SUBSCRIBE_KEY,
                userId: currentUser
            });
            
            pubnub.subscribe({ channels: [currentRoom] });
            
            pubnub.addListener({
                message: function(messageEvent) {
                    handleIncomingMessage(messageEvent.message);
                },
                status: function(statusEvent) {
                    handleConnectionStatus(statusEvent);

                    // When successfully connected, fetch message history
                    if (statusEvent.category === 'PNConnectedCategory') {
                        fetchMessageHistory();
                    }
                }
            });
            
            // If storyteller, send game setup
            if (userType === 'storyteller') {
                setTimeout(() => {
                    sendGameSetup();
                }, 1000);
            }
        }

        function fetchMessageHistory() {
            // Fetch the last 100 messages (adjust count as needed)
            pubnub.history({
                channel: currentRoom,
                count: 100, // Max messages to fetch
                reverse: false // false = newest first, true = oldest first
            }).then((response) => {
                if (response.messages && response.messages.length > 0) {
                    // Process messages in chronological order (oldest first)
                    const messages = response.messages.reverse();
                    
                    messages.forEach(messageWrapper => {
                        // PubNub history wraps messages in an object with timetoken
                        const message = messageWrapper.entry;
                        handleIncomingMessage(message, true); // true = from history
                    });
                }
            }).catch((error) => {
                console.log('Error fetching message history:', error);
            });
        }
        
        function handleConnectionStatus(statusEvent) {
            const statusEl = document.getElementById('connectionStatus');
            
            if (statusEvent.category === 'PNConnectedCategory') {
                isConnected = true;
                statusEl.textContent = 'Connected';
                statusEl.className = 'status connected';
            } else if (statusEvent.category === 'PNNetworkDownCategory') {
                isConnected = false;
                statusEl.textContent = 'Connection lost';
                statusEl.className = 'status disconnected';
            }
        }
        
        function sendGameSetup() {
	  console.log('sendGameSetup called, currentScript:', currentScript); // Add this line
          const setupMessage = {
                type: 'game_setup',
                players: players,
                script: currentScript,
                storyteller: currentUser,
                timestamp: Date.now()
            };
            
            pubnub.publish({
                channel: currentRoom,
                message: setupMessage
            });
        }
        
        function handleIncomingMessage(message, isFromHistory = false) {
            if (message.type === 'game_setup') {
                // Only process if this is the most recent setup message we've seen
                if (message.timestamp >= mostRecentSetupTimestamp) {
                    mostRecentSetupTimestamp = message.timestamp;
                    players = message.players;

                    // Look up the full script object from the script name/id
                    if (typeof message.script === 'string') {
                        // If it's just a name, find the script by name
                        currentScript = Object.values(EMBEDDED_SCRIPTS).find(s => s.name === message.script) ||
                                       EMBEDDED_SCRIPTS[message.script];
                    } else {
                        // If it's already an object, use it directly
                        currentScript = message.script;
                    }

                    updatePlayersList();
               }
               // If it's an older setup message, just ignore it
            } else if (message.type === 'request_game_state' && userType === 'storyteller') {
                // Don't respond to historical requests
                if (!isFromHistory) {
                    sendGameSetup();
                }
            } else if (message.type === 'private_message') {
                // Check if this is an echo of our own message
                if (message.from === currentUser && sentMessages.has(message.timestamp)) {
                    // This is an echo - mark the local message as delivered
                    markMessageDelivered(message.timestamp);
                    return; // Don't display duplicate
                }
                
                // If it's not our message or not in sent messages, display normally
                displayMessage(message);
            }
        }
        
        function switchToGameScreen() {
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            
            document.getElementById('displayRoom').textContent = currentRoom;
            
            if (currentScript) {
                document.getElementById('displayScript').textContent = currentScript.name;
                updateScriptViewer();
            }
            
            if (userType === 'storyteller') {
                document.getElementById('storytellerControls').classList.remove('hidden');
            }
            
            updatePlayersList();
        }
        
        function updatePlayersList() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                playerCard.textContent = player;
                
                if (player === currentUser) {
                    playerCard.classList.add('online');
                }
                
                playersList.appendChild(playerCard);
            });
            
            if (userType === 'player') {
                const storytellerCard = document.createElement('div');
                storytellerCard.className = 'player-card storyteller';
                storytellerCard.textContent = '👑 Storyteller';
                playersList.appendChild(storytellerCard);
            } else if (userType == 'storyteller') {
                // Update target player dropdown for storytellers
                const targetSelect = document.getElementById('targetPlayer');
                targetSelect.innerHTML = '<option value="">Select player...</option>';
                players.forEach(player => {
                    const option = document.createElement('option');
                    option.value = player;
                    option.textContent = player;
                    targetSelect.appendChild(option);
                });
            }
        }
        
        // Template Functions
        function useSimpleTemplate(template, fieldType) {
            const targetPlayer = document.getElementById('targetPlayer').value;
            if (!targetPlayer) {
                alert('Please select a target player first');
                return;
            }
            
            currentTemplate = {
                type: 'storyteller_info',
                template: template,
                to: targetPlayer,
                fields: [{ name: fieldType, type: fieldType }]
            };
            
            showTemplateUI();
        }
        
        function usePromptTemplate(promptText, responseTemplate, fieldTypes) {
            const targetPlayer = document.getElementById('targetPlayer').value;
            if (!targetPlayer) {
                alert('Please select a target player first');
                return;
            }
            
            currentTemplate = {
                type: 'player_prompt',
                promptText: promptText,
                responseTemplate: responseTemplate,
                to: targetPlayer,
                fields: fieldTypes.map(type => ({ name: type, type: type }))
            };
            
            showTemplateUI();
        }
        
        function showTemplateUI() {
            const templateUI = document.getElementById('templateUI');
            const templateTitle = document.getElementById('templateTitle');
            const templateFields = document.getElementById('templateFields');
            
            templateUI.classList.remove('hidden');
            
            if (currentTemplate.type === 'storyteller_info') {
                templateTitle.textContent = `Send Info to ${currentTemplate.to}`;
                templateFields.innerHTML = '';
                
                currentTemplate.fields.forEach(field => {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'template-field';
                    
                    const label = document.createElement('label');
                    label.textContent = field.name.charAt(0).toUpperCase() + field.name.slice(1) + ':';
                    
                    let input;
                    if (field.type === 'player') {
                        input = document.createElement('select');
                        input.innerHTML = '<option value="">Select player...</option>';
                        players.forEach(player => {
                            const option = document.createElement('option');
                            option.value = player;
                            option.textContent = player;
                            input.appendChild(option);
                        });
                    } else if (field.type === 'role') {
                        input = document.createElement('select');
                        input.innerHTML = '<option value="">Select role...</option>';
                        if (currentScript && currentScript.roles) {
                            currentScript.roles.forEach(role => {
                                const option = document.createElement('option');
                                option.value = role.id;
                                option.textContent = role.name;
                                input.appendChild(option);
                            });
                        }
                    } else {
                        input = document.createElement('input');
                        input.type = 'text';
                        input.placeholder = `Enter ${field.name}...`;
                    }
                    
                    input.id = `field_${field.name}`;
                    
                    fieldDiv.appendChild(label);
                    fieldDiv.appendChild(input);
                    templateFields.appendChild(fieldDiv);
                });
                
            } else if (currentTemplate.type === 'player_prompt') {
                templateTitle.textContent = `Send Prompt to ${currentTemplate.to}`;
                templateFields.innerHTML = `<p><strong>You will send:</strong> "${currentTemplate.promptText}"</p>`;
            }
        }
        
        function sendTemplateMessage() {
            if (!currentTemplate) return;
            
            let messageContent;
            let templateData = {};
            
            if (currentTemplate.type === 'storyteller_info') {
                // First: Validate ALL fields before processing ANY
                for (const field of currentTemplate.fields) {
                    const inputEl = document.getElementById(`field_${field.name}`);
                    const value = inputEl.value;
            
                    if (!value) {
                        alert(`Please fill in ${field.name}`);
                        return; // Actually exits the function
                    }
                }

                // Process storyteller template
                messageContent = currentTemplate.template;
                
                currentTemplate.fields.forEach(field => {
                    const inputEl = document.getElementById(`field_${field.name}`);
                    const value = inputEl.value;
                    // we know value is present (and truthy) because we checked it above
                    
                    templateData[field.name] = value;
                    
                    // Replace placeholder in message
                    if (field.type === 'role' && currentScript) {
                        const role = currentScript.roles.find(r => r.id === value);
                        if (role) {
                            messageContent = messageContent.replace(`{${field.name}}`, role.name);
                        } else {
                            messageContent = messageContent.replace(`{${field.name}}`, value);
                        }
                    } else {
                        messageContent = messageContent.replace(`{${field.name}}`, value);
                    }
                });
                
            } else if (currentTemplate.type === 'player_prompt') {
                messageContent = currentTemplate.promptText;
                templateData.responseTemplate = currentTemplate.responseTemplate;
                templateData.responseFields = currentTemplate.fields;
            }
            
            const message = {
                type: 'private_message',
                messageType: currentTemplate.type === 'storyteller_info' ? 'info' : 'prompt',
                from: currentUser,
                to: currentTemplate.to,
                content: messageContent,
                templateData: templateData,
                timestamp: Date.now()
            };

            // Display locally first (as "sending")
            displayMessage(message, true);
            sentMessages.set(message.timestamp, true);

            pubnub.publish({
                channel: currentRoom,
                message: message
            });
            
            cancelTemplate();
        }
        
        function cancelTemplate() {
            currentTemplate = null;
            document.getElementById('templateUI').classList.add('hidden');
            document.getElementById('responsePreview').classList.add('hidden');
        }
        
        function sendFreeMessage() {
            const messageInput = document.getElementById('messageInput');
            const messageText = messageInput.value.trim();
            
            if (!messageText || !isConnected) return;
            
            let to = 'Storyteller';
            if (userType === 'storyteller') {
                to = document.getElementById('targetPlayer').value;
                if (!to) {
                    alert('Please select a target player');
                    return;
                }
            }
            
            const message = {
                type: 'private_message',
                messageType: 'response',
                from: currentUser,
                to: to,
                content: messageText,
                timestamp: Date.now()
            };

            // Display locally first (as "sending")
            displayMessage(message, true);
            sentMessages.set(message.timestamp, true);
            
            pubnub.publish({
                channel: currentRoom,
                message: message
            });
            
            messageInput.value = '';
        }
        
        function displayMessage(message, isLocalSend = false) {
            // Only show messages for current user
            if (message.to !== currentUser && message.from !== currentUser) {
                return;
            }
            
            const messagesContainer = document.getElementById('messages');
            const messageEl = document.createElement('div');
            
            messageEl.className = 'message';
            if (message.from === 'Storyteller' || userType === 'player' && message.from !== currentUser) {
                messageEl.classList.add('from-storyteller');
            } else {
                messageEl.classList.add('from-player');
            }
            
            const headerEl = document.createElement('div');
            headerEl.className = 'message-header';
            const time = new Date(message.timestamp).toLocaleTimeString();
            
            let statusIcon = '';
            if (isLocalSend) {
                statusIcon = ' ⏳'; // Sending indicator
            } else if (message.from === currentUser) {
                statusIcon = ' ✓'; // Delivered indicator
            }
            
            headerEl.innerHTML = `${message.from} → ${message.to} (${time})<span class="delivery-status">${statusIcon}</span>`;
                 
            const contentEl = document.createElement('div');
            contentEl.textContent = message.content;
            
            // Store reference for delivery confirmation
            messageEl.dataset.timestamp = message.timestamp;
            messageEl.appendChild(headerEl);
            messageEl.appendChild(contentEl);
            
            // Add response UI for prompts
            if (message.messageType === 'prompt' && message.to === currentUser && userType === 'player') {
                const responseData = message.templateData;
                if (responseData && responseData.responseTemplate) {
                    const responseUI = createResponseUI(responseData, message);
                    messageEl.appendChild(responseUI);
                }
            }
            
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function markMessageDelivered(timestamp) {
            // Find the message element and update its delivery status
            const messageEl = document.querySelector(`[data-timestamp="${timestamp}"]`);
            if (messageEl) {
                const headerEl = messageEl.querySelector('.message-header');
                headerEl.innerHTML = headerEl.innerHTML.replace('⏳', '✓');
            }
        }

        function createResponseUI(responseData, originalMessage) {
            const responseDiv = document.createElement('div');
            responseDiv.className = 'template-ui';
            responseDiv.style.marginTop = '10px';
            
            const title = document.createElement('h4');
            title.textContent = 'Your Response:';
            responseDiv.appendChild(title);
            
            const fieldsDiv = document.createElement('div');
            
            responseData.responseFields.forEach(field => {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'template-field';
                
                const label = document.createElement('label');
                label.textContent = field.name.charAt(0).toUpperCase() + field.name.slice(1) + ':';
                
                let input;
                if (field.type === 'player') {
                    input = document.createElement('select');
                    input.innerHTML = '<option value="">Select player...</option>';
                    players.forEach(player => {
                        if (player !== currentUser) { // Don't include self
                            const option = document.createElement('option');
                            option.value = player;
                            option.textContent = player;
                            input.appendChild(option);
                        }
                    });
                } else {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = `Enter ${field.name}...`;
                }
                
                input.className = 'response-field';
                input.dataset.fieldName = field.name;
                
                // Update preview on change
                input.addEventListener('input', () => updateResponsePreview(responseDiv, responseData));
                input.addEventListener('change', () => updateResponsePreview(responseDiv, responseData));
                
                fieldDiv.appendChild(label);
                fieldDiv.appendChild(input);
                fieldsDiv.appendChild(fieldDiv);
            });
            
            responseDiv.appendChild(fieldsDiv);
            
            // Preview area
            const previewDiv = document.createElement('div');
            previewDiv.className = 'response-preview';
            previewDiv.textContent = 'Fill in the fields to see your response...';
            responseDiv.appendChild(previewDiv);
            
            // Send button
            const sendBtn = document.createElement('button');
            sendBtn.textContent = 'Send Response';
            sendBtn.onclick = () => sendPlayerResponse(responseDiv, responseData, originalMessage);
            responseDiv.appendChild(sendBtn);
            
            return responseDiv;
        }
        
        function updateResponsePreview(responseDiv, responseData) {
            const preview = responseDiv.querySelector('.response-preview');
            const fields = responseDiv.querySelectorAll('.response-field');
            
            let responseText = responseData.responseTemplate;
            let allFilled = true;
            
            fields.forEach(field => {
                const fieldName = field.dataset.fieldName;
                const value = field.value;
                
                if (value) {
                    responseText = responseText.replace(`{${fieldName}}`, value);
                } else {
                    allFilled = false;
                }
            });
            
            if (allFilled) {
                preview.textContent = `"${responseText}"`;
                preview.style.color = '#26de81';
            } else {
                preview.textContent = responseText;
                preview.style.color = '#ffd93d';
            }
        }
        
        function sendPlayerResponse(responseDiv, responseData, originalMessage) {
            const fields = responseDiv.querySelectorAll('.response-field');
            const fieldData = {};
            let responseText = responseData.responseTemplate;
            let allFilled = true;
            
            fields.forEach(field => {
                const fieldName = field.dataset.fieldName;
                const value = field.value;
                
                if (!value) {
                    allFilled = false;
                } else {
                    fieldData[fieldName] = value;
                    responseText = responseText.replace(`{${fieldName}}`, value);
                }
            });
            
            if (!allFilled) {
                alert('Please fill in all fields');
                return;
            }
            
            const message = {
                type: 'private_message',
                messageType: 'response',
                from: currentUser,
                to: originalMessage.from,
                content: responseText,
                respondingTo: originalMessage.timestamp,
                templateData: fieldData,
                timestamp: Date.now()
            };
            
            // Display locally first (as "sending")
            displayMessage(message, true);
            sentMessages.set(message.timestamp, true);

            pubnub.publish({
                channel: currentRoom,
                message: message
            });
            
            // Disable the response UI
            responseDiv.style.opacity = '0.5';
            responseDiv.style.pointerEvents = 'none';
            const sendBtn = responseDiv.querySelector('button');
            if (sendBtn) sendBtn.textContent = 'Response Sent';
        }
        
        // Script Viewer Functions
        function toggleScriptViewer() {
            const viewer = document.getElementById('scriptViewer');
            viewer.classList.toggle('hidden');
            
            if (!viewer.classList.contains('hidden') && currentScript) {
                updateScriptViewer();
            }
        }
        
        function updateScriptViewer() {
            if (!currentScript) return;
            
            const title = document.getElementById('scriptViewerTitle');
            const content = document.getElementById('scriptContent');
            
            title.textContent = currentScript.name;
            
            // Group roles by team
            const rolesByTeam = {
                townsfolk: [],
                outsider: [],
                minion: [],
                demon: []
            };
            
            currentScript.roles.forEach(role => {
                rolesByTeam[role.team].push(role);
            });
            
            // Build content
            let html = `
                <div style="margin-bottom: 15px;">
                    <strong>Author:</strong> ${currentScript.author || 'Unknown'}<br>
                    <strong>Description:</strong> ${currentScript.description || 'No description'}
                </div>
                <div class="script-viewer-content">
            `;
            
            // Render each team
            const teamInfo = {
                townsfolk: { name: 'Townsfolk', class: 'team-townsfolk' },
                outsider: { name: 'Outsiders', class: 'team-outsider' },
                minion: { name: 'Minions', class: 'team-minion' },
                demon: { name: 'Demons', class: 'team-demon' }
            };
            
            Object.entries(rolesByTeam).forEach(([team, roles]) => {
                if (roles.length > 0) {
                    const info = teamInfo[team];
                    html += `
                        <div class="team-section">
                            <div class="team-header ${info.class}">
                                ${info.name} (${roles.length})
                            </div>
                    `;
                    
                    roles.forEach(role => {
                        let timing = '';
                        if (role.firstNight && role.otherNights) {
                            timing = 'Acts first night and other nights';
                        } else if (role.firstNight) {
                            timing = 'Acts first night only';
                        } else if (role.otherNights) {
                            timing = 'Acts other nights only';
                        } else {
                            timing = 'Passive ability';
                        }
                        
                        html += `
                            <div class="role-card ${team}">
                                <div class="role-name">${role.name}</div>
                                <div class="role-ability">${role.ability}</div>
                                <div class="role-timing">${timing}</div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }
            });
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        // Handle Enter key in message input
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendFreeMessage();
            }
        });
        
        // Initialize setup screen
        document.getElementById('userType').dispatchEvent(new Event('change'));
      generateRoomId();
      populateScriptDropdown();
    </script>
</body>
</html>

<!--
     PROMPT SEQUENCE TO CLAUDE

     Project Summary: Local Smartphone Messaging App
Goal
Create a web-hosted app for smartphones that allows nearby co-located devices to communicate through short text messages, without going through third-party servers. Key requirements:
* Works on both iOS Safari and Android Chrome
* Smartphones are physically nearby/co-located
* Communication hidden from human observers in the area
* Messages don't need security against internet attackers
* Primary use case: short text messages between devices
Technical Journey & Rejected Options
1. Web Bluetooth API ❌
* Rejected: Not supported on iOS Safari
2. QR Code + WebRTC for Direct P2P ❌
* Rejected: WebRTC signaling complexity without servers proved too difficult
3. "No Third-Party Server" Requirement ❌
* Pivoted: Realized messages only need to be hidden from nearby humans, not secured against internet threats
* New approach: Public messaging APIs where messages are posted publicly, live temporarily (24 hours), with isolated feeds per "room"
4. Firebase Realtime Database ⭐⭐⭐⭐⭐
* Real-time WebSocket push, perfect room isolation, generous free tier
* Issue: More complex setup (auth, security rules) = 6-8 hours development
5. Other Services Evaluated:
* Pusher: Good but limited free tier ⭐⭐⭐⭐
* JSONBin.io/GitHub Gists: Polling only, not real-time ⭐⭐
* MQTT: Protocol-level solution requiring broker setup, WebSocket bridges for browsers - massive overkill for simple friend messaging
Current Plan: PubNub
Selected because:
* Purpose-built for exactly this use case
* 2-3 hours total development time vs 6-8+ for alternatives
* Works in browsers out-of-the-box (no server setup needed)
* $49/month cost acceptable for temporary friend project vs weeks of development time
* Simple 3-line implementation: subscribe(), publish(), addListener()
Status: Working prototype already built and tested. Ready for deployment with real PubNub keys.
User Context: Developer with limited free time, willing to pay modest amount ($49-100/month) for few months to deliver working app to friends quickly rather than spend weeks on complex setup.

To add a little extra context here: I want to prototype the smart phone app quickly. The main goal is to have an app where I, a game master for an instance of Blood on the Clocktower, can 1. start the app on the my phone, 2. choose a script (presumably I will have uploaded the choices to https://botc-scripts.azurewebsites.net/), 3. input the names of the group of players, 4. have my friends likewise open up the same website, choose their player name from the list, and 5. now we are all playing the game together, where I can send private messages to each player (via pub nub) and then they can likewise respond to my messages. In this way, I will be able to give them information about which role they have received, or what information they learned in each night phase of the game, or ask them to use their power (e.g. choose a player, and/or a role on the current script), and then I may respond with information according to what their power is. The main point is the messages should be able to be free-form human text, but there is also a presumed structure to most of the interactions that we will want to leverage, such as expecting the demon to choose a player each night, and thus it will be useful in the app for me, as the storyteller, to be able to send a message payload that will include, A. the message displayed to the user, and B. a template for what their likely response will be, such as "I choose {player}", where the "{player}" will be interpreted by the app as a place where one can click it and it brings up a combo box with all the players in the current game.

In case its not clear, I do want this to be a single page web app that I can just host on my server.


     F: I'm not quite sure if your state machine is set up correctly here. In particular, I was thinking that if the Storyteller has already created the game, then each player should just have to type the correct room id. Once they've typed a correct room id, then they select their name from the list of players associated with that room, and get to join. The way your code seems to be set up, the player is given a button to Generate a New Room, and it never fills the combo box with the names. But maybe I am doing something wrong with my own flow?

     (Claude fixed the above. We then went on a wild goose chase eplorting ways to modularize the code, which is probably important for a long-lived vibe-coded engineering effort, but I eventually recognized as being a bad use of time for this small scale thing.)


     F: I'm working on a little prototype. I'm actually pretty happy with it so far. Here's the one big thing that I think is missing: It is meant to capture semi-private messaging between some players in a game. It uses PubNub to deal with sending the messages. (They aren't real secrets.) Here's the problem: I was hoping that if I reloaded the page, and then reconnected to the same room, that I would see my current state reloaded; as in, the past messages that were still accessible via PubNub would load up. Is that not the way that PubNub works? Do the messages disappear from PubNub after a participant observes them? Or do I just need to adjust the code to reload the visible messages when connecting to a running game?

     F: Can you show me the necessary changes as a diff that I would need to apply to the file I showed you?


     F: I'm really happy with your help with this app I'm making. One problem I've noticed (or maybe its deliberate): Each message is showing up twice in a senders view. Its seen once on the recipients view. I assume this is something where the code is probably adding the text to the local buffer based on it being locally typed, and then adding it again when it shows up in the pubnub service. Does that sound plausible? See attached. Also, please show your suggestions on how to change this as diffs against the code.


     F: I don't necessarily want to remove the immediate local display. Could we consider detecting the echo and rendering some kind of annotation on the message showing that it made it to the pubnub service, like a little checkmark or something in the rendering near the timestamp?     

     F: Look at this code, especially the todo list at the top of the file.

     F: I'm very concerned about the oddities I'm seeing with the set of players and seeming corruption

     F: Wow that's a lot more code than I was expecting. I'm not terribly familiar wit hthis domain; is there no simpler way to accomplish this?

     F: what's wrong with looking at the timestamps and treating the most recent ones as the source of truth?

     F: Well you don't have to take my word at face value. Is there any potential issue with this approach?

     F: Okay. So what does this fix look like as a diff to the current file?

     F: Hmm. It didn't seem to work; I made a new game with the new code and with a larger player list, but it still seems to inherit the old player set associated with this room.

     F: Why did you reduce the delay?
-->
